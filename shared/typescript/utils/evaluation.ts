import { RetrievedChunk } from "./types";

/**
 * Simple evaluation utilities for RAG systems.
 *
 * These are lightweight helpers for comparing answers and scoring retrieval.
 * For more comprehensive evaluation, see Phase 5 evaluation projects.
 */

/**
 * Computes a simple similarity score between two answer strings.
 *
 * This function uses a basic word overlap metric to compare answers.
 * It's useful for quick validation scenarios but not suitable for
 * production evaluation.
 *
 * **How it works**:
 * 1. Normalizes both strings (lowercase, removes punctuation)
 * 2. Splits into word sets
 * 3. Computes Jaccard similarity (intersection / union)
 *
 * **Limitations**:
 * - Doesn't account for semantic similarity
 * - Doesn't handle paraphrasing
 * - Simple word matching only
 *
 * @param actual - The actual answer generated by the system
 * @param expected - The expected answer (ground truth)
 * @returns Similarity score between 0 (no overlap) and 1 (identical)
 *
 * @example
 * ```typescript
 * const score = compareAnswers(
 *   "Climate change is caused by greenhouse gases",
 *   "Greenhouse gases cause climate change"
 * );
 * // Returns: ~0.8 (high overlap despite word order difference)
 * ```
 */
export function compareAnswers(actual: string, expected: string): number {
  // Normalize: lowercase, remove punctuation, split into words
  const normalize = (text: string): Set<string> => {
    return new Set(
      text
        .toLowerCase()
        .replace(/[^\w\s]/g, " ")
        .split(/\s+/)
        .filter((word) => word.length > 0)
    );
  };

  const actualWords = normalize(actual);
  const expectedWords = normalize(expected);

  if (actualWords.size === 0 && expectedWords.size === 0) {
    return 1.0;
  }
  if (actualWords.size === 0 || expectedWords.size === 0) {
    return 0.0;
  }

  // Compute intersection and union
  const intersection = new Set([...actualWords].filter((w) => expectedWords.has(w)));
  const union = new Set([...actualWords, ...expectedWords]);

  // Jaccard similarity
  return intersection.size / union.size;
}

/**
 * Scores retrieval quality based on keyword overlap.
 *
 * This function checks how many expected keywords appear in the retrieved
 * chunks. It's useful for quick validation but doesn't account for semantic
 * relevance or answer quality.
 *
 * **How it works**:
 * 1. Normalizes expected keywords (lowercase)
 * 2. Checks how many keywords appear in retrieved chunk content
 * 3. Returns the ratio of matched keywords to total keywords
 *
 * **Limitations**:
 * - Only checks for exact keyword matches (no semantic understanding)
 * - Doesn't verify answer quality
 * - Simple presence check, not relevance scoring
 *
 * @param retrieved - Array of retrieved chunks with content
 * @param expectedKeywords - Array of keywords that should appear in relevant chunks
 * @returns Score between 0 (no keywords found) and 1 (all keywords found)
 *
 * @example
 * ```typescript
 * const score = scoreRetrieval(
 *   [
 *     { id: "c1", content: "Revenue increased by 20%", ... },
 *     { id: "c2", content: "Profit margins improved", ... }
 *   ],
 *   ["revenue", "profit", "margin"]
 * );
 * // Returns: 1.0 (all keywords found across chunks)
 * ```
 */
export function scoreRetrieval(
  retrieved: RetrievedChunk[],
  expectedKeywords: string[]
): number {
  if (expectedKeywords.length === 0) {
    return 1.0; // No keywords to check
  }
  if (retrieved.length === 0) {
    return 0.0; // No chunks retrieved
  }

  // Normalize keywords
  const normalizedKeywords = expectedKeywords.map((kw) => kw.toLowerCase());
  const allContent = retrieved.map((chunk) => chunk.content.toLowerCase()).join(" ");

  // Count how many keywords appear in the content
  const matchedKeywords = normalizedKeywords.filter((keyword) =>
    allContent.includes(keyword)
  ).length;

  return matchedKeywords / expectedKeywords.length;
}

