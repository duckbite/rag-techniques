import { RetrievedChunk } from "./types";

/**
 * Simple evaluation utilities for RAG systems.
 *
 * These are lightweight helpers for comparing answers and scoring retrieval.
 * For more comprehensive evaluation, see Phase 5 evaluation projects.
 */

/**
 * Computes a simple similarity score between two answer strings.
 *
 * This function uses a basic word overlap metric to compare answers.
 * It's useful for quick validation scenarios but not suitable for
 * production evaluation.
 *
 * **How it works**:
 * 1. Normalizes both strings (lowercase, removes punctuation)
 * 2. Splits into word sets
 * 3. Computes Jaccard similarity (intersection / union)
 *
 * **Limitations**:
 * - Doesn't account for semantic similarity
 * - Doesn't handle paraphrasing
 * - Simple word matching only
 *
 * @param actual - The actual answer generated by the system
 * @param expected - The expected answer (ground truth)
 * @returns Similarity score between 0 (no overlap) and 1 (identical)
 *
 * @example
 * ```typescript
 * const score = compareAnswers(
 *   "Climate change is caused by greenhouse gases",
 *   "Greenhouse gases cause climate change"
 * );
 * // Returns: ~0.8 (high overlap despite word order difference)
 * ```
 */
export function compareAnswers(actual: string, expected: string): number {
  // Normalize: lowercase, remove punctuation, split into words
  const normalize = (text: string): Set<string> => {
    return new Set(
      text
        .toLowerCase()
        .replace(/[^\w\s]/g, " ")
        .split(/\s+/)
        .filter((word) => word.length > 0)
    );
  };

  const actualWords = normalize(actual);
  const expectedWords = normalize(expected);

  if (actualWords.size === 0 && expectedWords.size === 0) {
    return 1.0;
  }
  if (actualWords.size === 0 || expectedWords.size === 0) {
    return 0.0;
  }

  // Compute intersection and union
  const intersection = new Set([...actualWords].filter((w) => expectedWords.has(w)));
  const union = new Set([...actualWords, ...expectedWords]);

  // Jaccard similarity
  return intersection.size / union.size;
}

/**
 * Scores retrieval quality based on keyword overlap.
 *
 * This function checks how many expected keywords appear in the retrieved
 * chunks. It's useful for quick validation but doesn't account for semantic
 * relevance or answer quality.
 *
 * **How it works**:
 * 1. Normalizes expected keywords (lowercase)
 * 2. Checks how many keywords appear in retrieved chunk content
 * 3. Returns the ratio of matched keywords to total keywords
 *
 * **Limitations**:
 * - Only checks for exact keyword matches (no semantic understanding)
 * - Doesn't verify answer quality
 * - Simple presence check, not relevance scoring
 *
 * @param retrieved - Array of retrieved chunks with content
 * @param expectedKeywords - Array of keywords that should appear in relevant chunks
 * @returns Score between 0 (no keywords found) and 1 (all keywords found)
 *
 * @example
 * ```typescript
 * const score = scoreRetrieval(
 *   [
 *     { id: "c1", content: "Revenue increased by 20%", ... },
 *     { id: "c2", content: "Profit margins improved", ... }
 *   ],
 *   ["revenue", "profit", "margin"]
 * );
 * // Returns: 1.0 (all keywords found across chunks)
 * ```
 */
export function scoreRetrieval(
  retrieved: RetrievedChunk[],
  expectedKeywords: string[]
): number {
  if (expectedKeywords.length === 0) {
    return 1.0; // No keywords to check
  }
  if (retrieved.length === 0) {
    return 0.0; // No chunks retrieved
  }

  // Normalize keywords
  const normalizedKeywords = expectedKeywords.map((kw) => kw.toLowerCase());
  const allContent = retrieved.map((chunk) => chunk.content.toLowerCase()).join(" ");

  // Count how many keywords appear in the content
  const matchedKeywords = normalizedKeywords.filter((keyword) =>
    allContent.includes(keyword)
  ).length;

  return matchedKeywords / expectedKeywords.length;
}

/**
 * Stitches adjacent retrieved chunks from the same document into longer
 * segments, up to a maximum character budget per segment.
 *
 * This is useful for techniques like relevant segment extraction and
 * context-window expansion where we want to provide the model with a
 * slightly larger, contiguous view of the source document instead of
 * many tiny disjoint chunks.
 *
 * The function only has access to the retrieved chunks themselves, so it
 * stitches together chunks that:
 * - Belong to the same document
 * - Have monotonically increasing indices
 * - Are present in the retrieved set
 *
 * @param retrieved - Retrieved chunks sorted by relevance
 * @param maxCharsPerSegment - Maximum number of characters per stitched segment
 * @returns New array of stitched chunks (still of type RetrievedChunk)
 */
export function stitchRetrievedChunks(
  retrieved: RetrievedChunk[],
  maxCharsPerSegment = 800
): RetrievedChunk[] {
  if (retrieved.length === 0) {
    return [];
  }

  // Group by documentId and sort by index within each group
  const byDoc = new Map<string, RetrievedChunk[]>();
  for (const chunk of retrieved) {
    const group = byDoc.get(chunk.documentId) ?? [];
    group.push(chunk);
    byDoc.set(chunk.documentId, group);
  }
  for (const group of byDoc.values()) {
    group.sort((a, b) => a.index - b.index);
  }

  const stitched: RetrievedChunk[] = [];

  for (const [documentId, group] of byDoc.entries()) {
    let current: RetrievedChunk | null = null;

    for (const chunk of group) {
      if (!current) {
        current = { ...chunk };
        continue;
      }

      const sameDoc = chunk.documentId === documentId;
      const isNextIndex = chunk.index === current.index + 1;
      const candidateContent: string = `${current.content}\n\n${chunk.content}`;

      if (sameDoc && isNextIndex && candidateContent.length <= maxCharsPerSegment) {
        current = {
          ...current,
          content: candidateContent,
          // Keep the highest score within the stitched window
          score: Math.max(current.score, chunk.score)
        };
      } else {
        stitched.push(current);
        current = { ...chunk };
      }
    }

    if (current) {
      stitched.push(current);
    }
  }

  return stitched;
}

